<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[网站部署https笔记]]></title>
    <url>%2F2017%2F09%2F17%2F%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2https%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[nginx中nginx.conf配置12345678910111213141516171819server &#123; listen 443; server_name abc.com; ssl on; root /apps/blog/; charset utf-8; index index.html index.htm; ssl_certificate cert/214241154760428.pem; ssl_certificate_key cert/214241154760428.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; root /apps/blog/; index index.html index.htm; &#125; error_page 404 /404.html; &#125; 如果还想所有http请求全部转为https，在80端口增加：1rewrite ^/(.*)$ https://abc.com/$1 permanent; 其中如果报ssl的错误，应该就是因为装nginx的时候没有指定ssl配置项，要重新安装再覆盖nginx，具体如下：1、查看之前安装nginx的配置项参数/usr/local/nginx/sbin/nginx -V2、进入nginx源码目录（原安装包目录）重新编译的代码和模块./configure --prefix=/usr/local/nginx--with-http_stub_status_module --with-http_ssl_module --with-file-aio --with-http_realip_module如果只是想用ssl可以这样：./configure --prefix=/usr/local/nginx--with-http_stub_status_module --with-http_ssl_module3、用make不要make install，否则就覆盖安装了，make完之后在objs目录（nginx源码包的objs）下就多了个nginx，覆盖你之前的nginx就可以了。cp objs/nginx /usr/local/nginx/sbin/nginx4、测试是否成功/usr/local/nginx/sbin/nginx -tconfigure具体参数解释如下：```–prefix=PATH ： 指定nginx的安装目录。默认 /usr/local/nginx–conf-path=PATH ： 设置nginx.conf配置文件的路径。nginx允许使用不同的配置文件启动，通过命令行中的-c选项。默认为prefix/conf/nginx.conf–user=name： 设置nginx工作进程的用户。安装完成后，可以随时在nginx.conf配置文件更改user指令。默认的用户名是nobody。–group=name类似–with-pcre ： 设置PCRE库的源码路径，如果已通过yum方式安装，使用–with-pcre自动找到库文件。使用–with-pcre=PATH时，需要从PCRE网站下载pcre库的源码（版本4.4 - 8.30）并解压，剩下的就交给Nginx的./configure和make来完成。perl正则表达式使用在location指令和 ngx_http_rewrite_module模块中。–with-zlib=PATH ： 指定 zlib（版本1.1.3 - 1.2.5）的源码解压目录。在默认就启用的网络传输压缩模块ngx_http_gzip_module时需要使用zlib 。–with-http_ssl_module ： 使用https协议模块。默认情况下，该模块没有被构建。前提是openssl与openssl-devel已安装–with-http_stub_status_module ： 用来监控 Nginx 的当前状态–with-http_realip_module ： 通过这个模块允许我们改变客户端请求头中客户端IP地址值(例如X-Real-IP 或 X-Forwarded-For)，意义在于能够使得后台服务器记录原始客户端的IP地址–add-module=PATH ： 添加第三方外部模块，如nginx-sticky-module-ng或缓存模块。每次添加新的模块都要重新编译（Tengine可以在新加入module时无需重新编译）]]></content>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[车险项目总结]]></title>
    <url>%2F2017%2F09%2F10%2Fauto-insurance-project-summary%2F</url>
    <content type="text"><![CDATA[前言一个有点久的项目，前不久做的前后端分离，虽然相比较技术还是有点落后，很小白，还是总结一下，毕竟路还是得一步步的走。 后台： 系统整体架构是spring+springMVC、持久层是mybatis、连接池之前是c3p0后来连接池老是挂就换成了HikariCP。 服务器是tomcat、使用了开源项目tomcat-redis-session-manager持久化session到redis集群. 由于并发不高后台服务器就2台，项目过程中调用外部系统接口的地方很多，所以spring集成了zookeeper和dubbo缓解调用外部接口的负载. 公司系统很多JNDI配置方面集成了disconf。 前台： 前台服务器nginx、技术属于刀耕火种的时代，jquery一撸到底。 打包工具：ANT因为这个项目工程包含三个子项目（客户系统、定时任务、后台），开发的时候这三个项目关联性强，所以在一个工程里面也方便开发。有篇文章写的挺好的传送门。 配置文件：JNDI由于properties文件会因服务器环境或其他场景需要改动，是放在tomcat的conf目录下，具体可以使用spring的BeanFactoryPostProcessor类来进行加载，在XML文件中用${key}或者需要在相应的类文件中编写该key的setter方法，spring就会注入值了，具体代码如下：1234567891011&lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="order" value="1" /&gt; &lt;property name="ignoreUnresolvablePlaceholders" value="true" /&gt;&lt;!-- 忽略不可解析的 Placeholder --&gt; &lt;property name="systemPropertiesModeName" value="SYSTEM_PROPERTIES_MODE_OVERRIDE" /&gt;&lt;!-- 可以从jvm虚拟机的参数中获得配置信息 --&gt; &lt;property name="ignoreResourceNotFound" value="true" /&gt;&lt;!-- 忽略未找到的资源 --&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;file:$&#123;confPath&#125;/jndi.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 其中confPath变量是在tomcat的context.xml添加的环境变量，如：1&lt;Environment name=&quot;confPath&quot; value=&quot;$&#123;catalina.home&#125;/conf&quot; type=&quot;java.lang.String&quot; override=&quot;false&quot; /&gt; 后来由于服务器环境太多以及项目配置文件也增多，每次配置调整起来都比较麻烦，还容易出错，所以AMC系统与disconf系统做了深度整合，提供集中式配置管理服务，基于zookeeper实现对配置更改的实时推送，配置更改自动reload，需要在servlet.xml中添加一下代码，如：12345678910111213141516171819202122232425&lt;context:component-scan base-package="com.baidu" /&gt;&lt;aop:aspectj-autoproxy proxy-target-class="true" /&gt;&lt;context:annotation-config /&gt;&lt;bean id="disconfMgrBean" class="com.baidu.disconf.client.DisconfMgrBean" destroy-method="destroy"&gt; &lt;property name="scanPackage" value="com.baidu.disconf" /&gt;&lt;/bean&gt;&lt;bean id="disconfMgrBean2" class="com.baidu.disconf.client.DisconfMgrBeanSecond" init-method="init" destroy-method="destroy"&gt;&lt;/bean&gt;&lt;bean id="configproperties_disconf" class="com.baidu.disconf.client.addons.properties.ReloadablePropertiesFactoryBean"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;jndi.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id="propertyConfigurer_disconf" class="com.baidu.disconf.client.addons.properties.ReloadingPropertyPlaceholderConfigurer"&gt; &lt;property name="ignoreResourceNotFound" value="true" /&gt; &lt;property name="ignoreUnresolvablePlaceholders" value="true" /&gt; &lt;property name="propertiesArray"&gt; &lt;list&gt; &lt;ref bean="configproperties_disconf" /&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 那么业务系统如何连接AMC？需要在项目的classpath(源文件下或者src下)路径下添加两个文件名字必须一样（disconf.properties、disconf_sys.properties）。disconf_sys.properties文件内容说明如：12345678#获取配置文件根节点disconf.conf_server_store_action=/api/config#获取zookeeper地址disconf.conf_server_zoo_action=/api/zoo#获取远程主机个数的URLdisconf.conf_server_master_num_action=/api/getmasterinfo# 下载文件夹, 远程文件下载后会放在这里disconf.local_download_dir=/opt/server/conf disconf.properties文件内容即说明如：1234567891011121314151617181920#是否从云端下载配置 disconf.enable.remote.conf=true#忽略哪些分布式配置disconf.ignore=test#获取远程配置 重试次数，默认是3次disconf.conf_server_url_retry_times=3#获取远程配置 重试时休眠时间，默认是2秒disconf.conf_server_url_retry_sleep_seconds=2#让下载文件夹放在 classpath目录 下disconf.enable_local_download_dir_in_class_path=true#配置文件服务器 HOSTdisconf.conf_server_host=10.0.0.0#版本disconf.version=1_0_0#系统名称disconf.app=amc#部署环境disconf.env=sit#用户指定的 下载文件夹, 远程文件下载后会放在这里disconf.user_define_download_dir=/opt/server/conf 当在amc配置管理中心修改了jndi.properties配置文件并点更新按钮.项目中bean的属性值就修改了不用重启项目。注：项目一部分托管disconf管理，一部分spring管理的时候，spring管理的配置一定要写在disconf管理配置之后]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>项目总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口签名方式（代码）]]></title>
    <url>%2F2017%2F07%2F23%2FInterface-signature-mode-note(code)%2F</url>
    <content type="text"><![CDATA[Digest验证方式12345678910111213141516HttpResult result = sendRequest(uri, HttpMessage.METHOD_GET, null);int statusCode = result.getHttpResp().getStatusLine().getStatusCode();HttpResult resulthttpConnection.sendRequest(message)if (statusCode == HttpStatus.SC_OK) &#123; String resDoc = result.getHttpContent();else if (statusCode == HttpStatus.SC_UNAUTHORIZED) &#123; Header header = result.getHttpResp().getFirstHeader("WWW-Authenticate"); HashMap&lt;String, String&gt; authMap = parse(header.getValue()); String content = buildAuthHeader(uri, authMap, account, password); HttpHeader authHeader = new HttpHeader("Authorization", content); List&lt;HttpHeader&gt; list = new ArrayList&lt;HttpHeader&gt;(); list.add(authHeader); result = sendRequest(uri, HttpMessage.METHOD_GET, list); int statusCodeSec = result.getHttpResp().getStatusLine().getStatusCode(); if (statusCodeSec == HttpStatus.SC_OK) &#123; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public static HttpResult sendRequest(String uri, String method, List&lt;HttpHeader&gt; headers) &#123; HttpConnection httpConnection = HttpConnectionFactory.getDefaultConnection(); HttpMessage message = new HttpMessage(); message.setRequestUrl(uri); message.setMethod(method); message.addHeader("Content-Type", "application/json"); if (headers != null) &#123; for (HttpHeader header : headers) &#123; message.addHeader(header.getKey(), header.getValue()); &#125; &#125; return httpConnection.sendRequest(message); &#125;public static HashMap&lt;String, String&gt; parse(String authHeader) &#123; HashMap&lt;String, String&gt; headerMap = null; String header = authHeader.substring(authHeader.lastIndexOf("Digest") + "Digest ".length()); if (!KitUtil.isEmpty(header)) &#123; headerMap = new HashMap&lt;String, String&gt;(); String[] params = header.split(","); if (params != null &amp;&amp; params.length &gt; 0) &#123; for (String param : params) &#123; String[] data = param.split("="); String key = data[0].trim(); String value = ""; if (data.length &gt; 1) &#123; value = data[1].trim(); &#125; headerMap.put(key, value); &#125; &#125; &#125; return headerMap; &#125; static String buildAuthHeader(String uri, Map&lt;String, String&gt; authMap, String user, String password) &#123; String realm = authMap.get("realm"); realm = realm.substring(1, realm.length() - 1); String nonce = authMap.get("nonce"); nonce = nonce.substring(1, nonce.length() - 1); String qop = authMap.get("qop"); qop = qop.substring(1, qop.length() - 1); String opaque = authMap.get("opaque"); String ha1 = DigestUtils.md5Hex(user + ":" + realm + ":" + password); String ha2 = DigestUtils.md5Hex("GET:" + uri); String cnonce = UUID.randomUUID().toString(); String hashResponse = DigestUtils .md5Hex(ha1 + ":" + nonce + ":00000001:" + cnonce + ":" + qop + ":" + ha2); StringBuilder challengeText = new StringBuilder("Digest username=\""); challengeText.append(user).append("\","); challengeText.append("realm=\"").append(realm).append("\","); challengeText.append("nonce=\"").append(nonce).append("\","); challengeText.append("uri=\"").append(uri).append("\","); challengeText.append("qop=\"").append(qop).append("\","); challengeText.append("nc=\"").append("00000001").append("\","); challengeText.append("cnonce=\"").append(cnonce).append("\","); challengeText.append("response=\"").append(hashResponse).append("\","); challengeText.append("opaque=").append(opaque); return challengeText.toString(); &#125; 参数按字典升序后SHA1加密方式12345678910111213141516171819202122232425262728293031323334353637383940414243/***SHA1加密*/public static String SHA1(Map&lt;String,Object&gt; map,String secret)&#123; String aux = getOrderByLexicographic(map,secret); char hexDigits [] = &#123;'0' , '1' , '2' , '3' , '4', '5' , '6' , '7' , '8' , '9' , 'a', 'b', 'c', 'd', 'e', 'f'&#125;; MessageDigest mdTemp = null; try&#123; mdTemp = MessageDigest.getInstance("SHA1"); mdTemp.update(aux.getBytes("UTF-8")); &#125;catch (NoSuchAlgorithmException e1)&#123; e1.printStackTrace(); &#125;catch (UnsupportedEncodingException e)&#123; e.printStackTrace(); &#125; byte[] md = mdTemp.digest(); int j = md.length; char buf[] = new char[j * 2]; int k = 0; for (int i =0; i&lt;j;i++)&#123; byte _byte = md[i]; buf[k++] = hexDigits[_byte &gt;&gt;&gt; 4 &amp; 0xf]; buf[k++] = hexDigits[_byts &amp; 0xf]; &#125; return new String(buf);&#125;/***根据键名升序排列*/ private static String getOrderByLexicographic(Map&lt;String,Object&gt; map,String secret)&#123; StringBuffer aux = new StringBuffer(); for(String parName : Collections.sort(map.keySet()))&#123; for(Map.entry&lt;String,Object&gt; entry : map.entrySet())&#123; if(parName.equals(entry.getKey))&#123; aux.append(entry.getKey + "=" + String.valueOf(entry.getValue()) + "&amp;"); &#125; &#125; &#125; return aux.append(secret).toString().subString(0);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[接口签名方式（过程）]]></title>
    <url>%2F2017%2F07%2F19%2FInterface-signature-mode-note(process)%2F</url>
    <content type="text"><![CDATA[Digest验证方式 交互过程图 客户端发送get请求服务器，服务器判断需要认证并没有认证信息Authorization，返回状态码401 Unauthorized表示客户端错误，并且会在响应头增加WWW-Authenticate。 客户端收到服务器的401回复后，根据WWW-Authenticate里面的提示信息进行加密并重新发起请求。 服务器根据Authorization中username等信息进行签名，并将签名结果与客户端中的签名对比，如果一致则签名成功，返回响应信息并在响应头增加Authorization-Info 客户端再次请求服务器时增加Authorization-Info授权信息。 参数按字典序升序后SAH1加密签名规则：排除sign参数自身外，所有的参数按照键名升序，组合成key=value格式键值对，中间使用“&amp;”拼接，最后固定用“&amp;”拼接秘钥串，将得到的字符串进行SHA1加密作为参数sign的值。 参考链接https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Authentication]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[腾讯云服务器搭建笔记]]></title>
    <url>%2F2017%2F03%2F28%2FTencent-cloud-server-build-notes%2F</url>
    <content type="text"><![CDATA[我是利用Xshell工具连接的，其中用到lrzsz实现本地上传下载，安装方式是用的yum，如果不知道你要安装包的具体名称，可以使用yum provides */name 进行查找系统自带软件包的信息，yum install -y lrzsz安装这个包就可以实现上传下载了。 1 数据盘整理&emsp;&emsp;因为不可能所有东西都堆在系统盘，一些数据库、服务器等东西我感觉还是放在数据盘好点，不然等系统盘满了启动都是个问题，下面整理一下一开始数据盘的操作。 输入命令fdisk -l查看您的数据盘信息，注意：在没有分区和格式化数据盘之前，使用df -h命令是无法看到数据盘的。在下面的示例中，有一个 54 GB 的数据盘(/vdb)需要挂载。 执行以下命令，对数据盘进行分区。fdisk /dev/vdb，按照界面的提示，依次输入“n”(新建分区)、“p”(新建扩展分区)、“1”(使用第1个主分区)，两次回车(使用默认配置)，输入“wq”(保存分区表)，回车开始分区。这里是以创建1个分区为例，开发者也可以根据自己的需求创建多个分区，一般情况下只能有三个主分区和一个拓展分区。 分区后需要对分好的区进行格式化，您可自行决定文件系统的格式，如ext2、ext3等。本例以“ext3”为例，使用下面的命令对新分区进行格式化。mkfs.ext3 /dev/vdb1 使用以下命令创建mydata目录并将分区挂载在该目录下（其实就是给这个目录这个分区的空间）,创建目录mkdir /mydata,挂载分区mount /dev/vdb1 /mydata，最后使用命令查看df -h 如果希望云服务器在重启或开机时能自动挂载数据盘，必须将分区信息添加到/etc/fstab中。如果没有添加，则云服务器重启或重新开机后，都不能自动挂载数据盘。使用以下命令添加分区信息：echo &#39;/dev/vdb1 /mydata ext3 defaults 0 0&#39; &gt;&gt; /etc/fstab,使用以下命令查看cat /etc/fstab,出现如图信息则说明添加分区信息成功。 2 安装jdk &emsp;&emsp;jdk可以安装在系统盘下，一般用yum安装的默认在/usr/lib/jvm/下，我的是通过下载官方的tar.gz上传到上面然后解压到这个目录的。（jdk压缩包） 进去到需要安装的目录如cd /usr/lib/jvm/，备用拷贝命令cp /server/jdk-8u121-linux-x64.tar.gz /usr/lib/jvm/jdk8 解压jdk到当前目录tar -zxvf jdk-8u121-linux-x64.tar.gz 配置环境变量 1234export JAVA_HOME=/usr/lib/jvm/jdk8export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/binexport JAVA_HOME CLASSPATH PATH 重启机器或执行命令 ：source /etc/profile 1sudo shutdown -r now 查看安装情况java -version 可能出现的错误信息： 1bash: ./java: cannot execute binary file 出现这个错误的原因可能是在32位的操作系统上安装了64位的jdk，查看jdk版本和Linux版本位数是否一致。查看你安装的Ubuntu是32位还是64位系统： 123sudo uname --mi686 //表示是32位x86_64 // 表示是64位 3 安装tomcat&emsp;&emsp;我安装tomcat遇到一个坑，什么都配置好后tomcat启动后一直卡在INFO: Deploying web application directory，解决方法是找到jdk1.x.x_xx/jre/lib/security/Java.security文件，在文件中找到securerandom.source这个设置项，将其改为：securerandom.source=file:/dev/./urandom。DOMAIN临时：修改startWeblogic.sh文件，JAVA_OPTIONS=&quot;${SAVE_JAVA_OPTIONS} -Djava.security.egd=file:/dev/./urandom&quot; 上传及解压步骤如上]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开发常用工具和插件]]></title>
    <url>%2F2016%2F11%2F18%2FDevelopment-of-common-tools-and-plug-ins%2F</url>
    <content type="text"><![CDATA[插件1 spket 它是eclipse插件,开发有成效，创造高效率的javascript代码。 &emsp;&emsp;配置过程如下（spket压缩包）： 附件压缩包解压到自己的eclipse目录。 重启eclipse 设置js文件默认编辑器，Window &gt;&gt; Preferences &gt;&gt; General &gt;&gt; Editors &gt;&gt; File Associations 2 jad 查看架包源代码 &emsp;&emsp;配置过程如下（jad压缩包）: 首先，找到eclipse安装根目录，创建一个文件夹(jad)，将jad.exe放入其中 其次，找到plugins目录，将指定的解析架包(net.sf.jadclipse_3.3.0.jar)放入其中 然后eclipse重启，Window &gt;&gt; Preferences &gt;&gt;搜索jad，其中Path to decompiler中设置jad.exe的存放路径；Directory for temporary files中设置缓存，在本地专门建一个目录，存放，配置其地址,重启eclipse即可。 如果不能使用，无法反编译，则需要设置默认打开源文件的方式打开eclipse，Window &gt;&gt; Preferences &gt;&gt;搜索file，选择file types 是class without source的选项，设置打开方式，选择jadClipse Class file viewer，点击默认按钮default。]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github-ssh-key]]></title>
    <url>%2F2016%2F10%2F17%2Fgithub-ssh-key%2F</url>
    <content type="text"><![CDATA[查看是否已经生成过ssh key1ls -al ~/.ssh 生成密钥文件和私钥文件 id_rsa,id_rsa.pub或id_dsa,id_dsa.pu123ssh-keygen -t rsa -C &quot;email@qq.com&quot;会提示要你输入passphrase，我没有输入直接回车，如果你输入的话，要记得，到时候会用到 然后键入以下指令1ssh-agent -s 继续输入指令12ssh-add ~/.ssh/id_rsa在我这里是出错了，不知道你的有没有出错。 如果你的也是这样子出错了的话，就输入以下指令。12eval `ssh-agent -s`ssh-add 最后拷贝id_rsa.pub内容到github key。 linux小白顿时跪拜：-a：显示所有档案及目录（ls内定将档案名或目录名称为“.”的视为影藏，不会列出）。-l：以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等。keygen：注册机。-t：type指定要创建的密钥类型。可以使用：”rsa1”(SSH-1) “rsa”(SSH-2) “dsa”(SSH-2)。-C：添加注释，一般都是邮箱地址，一个标记吧。ssh-agent：命令是一种控制用来保存公钥身份验证所使用的私钥的程序。ssh-agent在X会话或登录会话之初启动，所有其他窗口或程序则以客户端程序的身份启动并加入到ssh-agent程序中。通过使用环境变量，可定位代理并在登录到其他使用ssh机器上时使用代理自动进行身份验证。-S：start 指定在生成 DH-GEX 候选模数时的起始点(16进制)。]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016/10 计划]]></title>
    <url>%2F2016%2F10%2F15%2F2016-10-plan%2F</url>
    <content type="text"><![CDATA[离过年还有将近四个月，今年的目标早就忘了啊，= =！ no.1 lively原型图、设计稿、html、前端框架 &gt;&gt; 10月底完成整体架构框架分析no.2 java编程思想每天10页，认真思考记录。 no.3 微信公众号 and 微信小程序订阅号启用开发者模式，写几个小功能，为lively做准备。熟悉微信小程序，编写demo。 no.4 技术学习方向spring、nodejs、angularjs、myBatis、mongodb no.5 javascript高级程序设计每天10页，认真思考记录。 凛冬将至。]]></content>
      <categories>
        <category>计划</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo常用命令]]></title>
    <url>%2F2016%2F10%2F15%2FHexo-common-commands%2F</url>
    <content type="text"><![CDATA[安装12npm install hexo -g 安装 npm update hexo -g 升级 基础123456hexo n &quot;pageName&quot; == hexo new &quot;pageName&quot; 新建文章hexo g == hexo generate 生成hexo s == hexo server 启动服务hexo s --debug log启动hexo d == hexo deploy 部署hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 发布到 github 有时候，本地的README文件hexo会自动解析成html，上传到github时候会冲掉。把’README.MD’文件的后缀名改成”MDOWN”然后扔到blog/source文件夹下即可，这样hexo不会解析，github也会将其作为MD文件解析。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
</search>
